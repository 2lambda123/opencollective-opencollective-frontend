import { has, isNil } from 'lodash';
import { parseToRgb, rgbToColorString } from 'polished';

import { centsAmountToFloat, floatAmountToCents } from './currency-utils';
import { parseToBoolean } from './utils';

/**
 * A tool to work with URL query parameters as generated by Next Router.
 */
export default class UrlQueryHelper {
  constructor(config) {
    this.config = config;
  }

  static Decoders = {
    amount: str => {
      if (isNil(str) || !str.length) {
        return null;
      } else {
        const result = floatAmountToCents(parseFloat(str));
        return isNaN(result) ? null : result;
      }
    },
    boolean: str => {
      return isNil(str) || !str.length ? null : parseToBoolean(str, null);
    },
    color: str => {
      if (!str) {
        return null;
      } else if (str.match(/^(?=\d*$)(?:.{3}|.{6}|.{8})$/)) {
        return `#${str}`; // Allow hex colors to be passed without the #
      } else {
        try {
          return rgbToColorString(parseToRgb(str));
        } catch {
          // Ignore errors, will return null
        }
      }

      return null;
    },
    integer: str => {
      if (isNil(str) || !str.length) {
        return null;
      } else {
        const result = parseInt(str);
        return isNaN(result) || !Number.isSafeInteger(result) ? null : result;
      }
    },
    interval: str => {
      const cleanStr = str?.trim()?.replace(/ly$/, ''); // support for "monthly"/"yearly"
      return ['month', 'year'].includes(cleanStr) ? cleanStr : null;
    },
    json: str => {
      try {
        return JSON.parse(str);
      } catch (err) {
        return null;
      }
    },
    stringArray: str => {
      return !str ? null : str.split(',');
    },
  };

  static Encoders = {
    amount: number => centsAmountToFloat(number).toString(),
    boolean: value => (value ? 'true' : 'false'),
    integer: value => value.toString(),
    json: value => JSON.stringify(value),
    stringArray: value => value.join(','),
  };

  /**
   * Decode a query object as provided by router.query according to `config`
   */
  decode(queryObject) {
    const result = {};
    Object.entries(this.config).forEach(([key, param]) => {
      if (!has(queryObject, key)) {
        return;
      }

      // Decode value
      const value = queryObject[key];
      const isAlias = param.type === 'alias';
      const targetKey = isAlias ? param.on : key;
      const fieldType = this.config[targetKey].type;
      const decoder = UrlQueryHelper.Decoders[fieldType];
      const decodedValue = decoder ? decoder(value) : value;
      result[targetKey] = param.modifier ? param.modifier(decodedValue) : decodedValue;
    });

    return result;
  }

  /**
   * Encode the values of `queryObject` to make it safe to pass in router.push
   */
  encode(queryObject) {
    const result = {};
    Object.entries(queryObject).forEach(([key, value]) => {
      const param = this.config[key];
      if (!param) {
        return;
      }

      // Encode value
      const isAlias = param.type === 'alias';
      const targetKey = isAlias ? param.on : key;
      const fieldType = this.config[targetKey].type;
      const encoder = UrlQueryHelper.Encoders[fieldType];
      const encodedValue = encoder ? encoder(value) : value;

      // If it's an aliased field, set the value on the referenced field
      result[targetKey] = encodedValue;
    });

    return result;
  }
}
